# zk_SNARK


## 多项式的性质与证明

* 任何多项式在任意点的计算结果都可以看做是其唯一身份的表示。
  
* 这也是为什么如果一个 prover 声称他知道一些 verifier 也知道的多项式（无论多项式的阶数有多大）时，他们就可以按照一个简单的协议去验证：
  * verifier 选择一个随机值 x 并在本地计算多项式结果
  * verifier 将 x 值给到 prover，并让他计算相关的多项式结果
  * prover 代入 x 到多项式计算并将结果给到 verifier
  * verifier 检查本地的计算结果和 prover 的计算结果是否相等，如果相等那就说明 prover 的陈述具有较高的可信度

* 利用多项式一致性检查协议我们就可以比较多项式 p(x) 和 t(x) ⋅ h(x)：
  * verifier 挑选一个随机值 r, 计算 t = t(r) (即，求值) ，然后将 r 发送给 prover。
  * prover 计算 h(x) =p(x) / t(x) ，并对 p(r) 和 h(r) 进行求值，将计算结果 p, h 提供给 verifier。
  * verifier 验证 p= t⋅h，如果多项式相等，就意味着 t(x) 是 p(x) 的因式。

```
Remark 3.1现在我们就可以在不知道多项式的前提下根据特定的性质来验证多项式了，这就已经给了我们一些零知识和简明性的特性。但是，这个结构中还存在好多问题：
  1 prover 可能并不知道他所声称的 p(x)，他可以先算一下 t = t(r)，然后选择一个随机值 h，由此计算出 p = t⋅h。因为等式是成立的，所以也能通过 verifier 的校验。

  2 因为 prover 知道随机点 x = r ，他可以构造出一个任意的多项式，这个任意多项式与 t(r) ⋅ h(r) 在 r 处有共同点。

  3 在前面的「陈述」中，prover 声称他知道一个特定阶数的多项式，但现在的协议对阶数并没有明确的要求。因而 prover 完全可以拿一个满足因式校验的更高阶数的多项式来欺骗 verifier。

```

* Remark 3.1 中的前两个问题是由于 暴露了原始值 而导致的，也就是 prover 知道了 r 和 t(r)。但如果 verifier 给出的这个值像放在黑盒里一样不可见的话就完美了，也就是一个人即使不破坏协议，也依然能在这些模糊的值上面完成计算。
  * 强同态加密:它允许加密一个值并在密文上进行算术运算

```
Remark 3.2 这个同态加密模式有一个限制，我们可以把一个加密的值和一个未加密的值相乘，但我们不能将两个加密的值相乘（或者相除），也就是说我们不能对加密值取幂。虽然这些性质第一感觉看起来很不友好，但是这却构成了 zk-SNARK 的基础。

```



